@isTest
private class GEN_AccountDocumentServiceTest {

    @testSetup
    static void setupData() {
        // 1. Create Account
        Account acc = new Account(
            Name = 'Test Account',
            Company_Registration_Number__c = '12345',
            Company_Registration_Location__c = 'London'
        );
        insert acc;

        // 2. Create Contact
        Contact con = new Contact(
            FirstName = 'Test',
            LastName = 'User',
            Email = 'test@example.com',
            AccountId = acc.Id
        );
        insert con;
    }

    // =================================================================
    // PART A: CONTROLLER & INTEGRATION TESTS (Happy Paths)
    // =================================================================

    @isTest
    static void testController_GetSendOptions() {
        Account acc = [SELECT Id FROM Account LIMIT 1];
        
        Test.startTest();
        Map<String, Object> result = GEN_AccountDocumentController.getSendOptions(acc.Id);
        Test.stopTest();

        System.assertEquals('success', result.get('message'));
        Map<String, Object> resp = (Map<String, Object>) result.get('response');
        System.assert(resp.containsKey('contacts'));
        System.assert(resp.containsKey('documents'));
    }

    @isTest
    static void testController_GenerateNDA() {
        Account acc = [SELECT Id FROM Account LIMIT 1];
        
        // UPDATED: Using your specific mock name
        Test.setMock(HttpCalloutMock.class, new GENAccountDocumentServiceMock());

        Test.startTest();
        Map<String, Object> result = GEN_AccountDocumentController.generateDocument('nda', acc.Id);
        Test.stopTest();

        System.assertEquals('success', result.get('message'));
        List<ContentVersion> cv = [SELECT Id FROM ContentVersion WHERE FirstPublishLocationId = :acc.Id];
        System.assertEquals(1, cv.size());
    }

    @isTest
    static void testController_GenerateRPA() {
        Account acc = [SELECT Id FROM Account LIMIT 1];
        Test.setMock(HttpCalloutMock.class, new GENAccountDocumentServiceMock());

        Test.startTest();
        Map<String, Object> result = GEN_AccountDocumentController.generateDocument('rpa', acc.Id);
        Test.stopTest();

        System.assertEquals('success', result.get('message'));
    }

    @isTest
    static void testController_SendSignature() {
        Account acc = [SELECT Id FROM Account LIMIT 1];
        Contact con = [SELECT Id FROM Contact LIMIT 1];

        // Create dummy file required for logic
        ContentVersion cv = new ContentVersion(
            Title = 'Test.pdf', PathOnClient = 'Test.pdf', VersionData = Blob.valueOf('Data'), FirstPublishLocationId = acc.Id
        );
        insert cv;
        Id docId = [SELECT ContentDocumentId FROM ContentVersion WHERE Id = :cv.Id].ContentDocumentId;

        Test.setMock(HttpCalloutMock.class, new GENAccountDocumentServiceMock());

        Test.startTest();
        Map<String, Object> result = GEN_AccountDocumentController.sendDocumentForSignature(con.Id, docId);
        Test.stopTest();

        System.assertEquals('success', result.get('message'));
    }

    // =================================================================
    // PART B: EXCEPTION HANDLING & VALIDATION (Maximizes Coverage)
    // =================================================================

    @isTest
    static void testController_SystemException() {
        // This test forces the Service to throw a NullPointer, which forces the Controller to catch it.
        // This covers the "catch (Exception e)" blocks in the Controller.
        Account acc = [SELECT Id FROM Account LIMIT 1];

        Test.startTest();
        // Passing NULL as documentType causes crash in Service
        Map<String, Object> result = GEN_AccountDocumentController.generateDocument(null, acc.Id);
        Test.stopTest();

        // Verify we caught the System Error
        System.assertEquals('error', result.get('message'));
        String msg = (String) result.get('response');
        System.assert(msg.contains('System Error'), 'Should catch the exception as System Error');
    }

    @isTest
    static void testService_Validations() {
        // Test 1: Missing Account
        Map<String, Object> res1 = GEN_AccountDocumentController.generateDocument('nda', '001000000000000AAA'); // Fake ID
        System.assertEquals('error', res1.get('message'));

        // Test 2: Missing Contact Email
        Contact con = [SELECT Id FROM Contact LIMIT 1];
        con.Email = null;
        update con;
        
        // We need a doc ID to reach the email check
        Account acc = [SELECT Id FROM Account LIMIT 1];
        ContentVersion cv = new ContentVersion(Title='T', PathOnClient='T.pdf', VersionData=Blob.valueOf('D'), FirstPublishLocationId=acc.Id);
        insert cv;
        Id docId = [SELECT ContentDocumentId FROM ContentVersion WHERE Id=:cv.Id].ContentDocumentId;

        Map<String, Object> res2 = GEN_AccountDocumentController.sendDocumentForSignature(con.Id, docId);
        System.assertEquals('error', res2.get('message'));
        // Check string conversion safely
        String errorMsg = String.valueOf(res2.get('response'));
        System.assert(errorMsg.contains('email missing'));
    }
    
    @isTest
    static void testService_BadGateway() {
        // This tests the logic we added to handle "HTML response" errors
        Account acc = [SELECT Id FROM Account LIMIT 1];
        Contact con = [SELECT Id FROM Contact LIMIT 1];
        con.Email = 'valid@test.com'; update con;
        
        ContentVersion cv = new ContentVersion(Title='T', PathOnClient='T.pdf', VersionData=Blob.valueOf('D'), FirstPublishLocationId=acc.Id);
        insert cv;
        Id docId = [SELECT ContentDocumentId FROM ContentVersion WHERE Id=:cv.Id].ContentDocumentId;

        // Configure Mock to return 502 HTML
        GENAccountDocumentServiceMock mock = new GENAccountDocumentServiceMock();
        mock.simulateBadGateway = true;
        Test.setMock(HttpCalloutMock.class, mock);

        Test.startTest();
        Map<String, Object> result = GEN_AccountDocumentController.sendDocumentForSignature(con.Id, docId);
        Test.stopTest();

        System.assertEquals('error', result.get('message'));
        String errorMsg = String.valueOf(result.get('response'));
        System.assert(errorMsg.contains('Bad Gateway') || errorMsg.contains('Auth Failed'));
    }

    // =================================================================
    // PART C: SELECTOR COVERAGE (Direct calls to boost percentage)
    // =================================================================

    @isTest
    static void testSelectorsDirectly() {
        // We instantiate selectors and call methods directly to ensure 100% class coverage
        
        Account acc = [SELECT Id FROM Account LIMIT 1];
        Contact con = [SELECT Id FROM Contact LIMIT 1];
        
        Test.startTest();

        // 1. ContentDocumentSelector
        GEN_ContentDocumentSelector docSel = new GEN_ContentDocumentSelector();
        docSel.getSObjectType();
        docSel.getSObjectFieldList();
        docSel.getDocumentsByLinkedEntity(acc.Id);
        docSel.getContentDocumentForSignature(null); 

        // 2. ContentVersionSelector
        GEN_ContentVersionSelector verSel = new GEN_ContentVersionSelector();
        verSel.getSObjectType();
        verSel.getSObjectFieldList();
        verSel.selectLatestPublishedVersion(null);

        // 3. ContactSelector
        GEN_ContactSelector conSel = new GEN_ContactSelector();
        conSel.getSObjectType();
        conSel.getSObjectFieldList();
        conSel.getContactsByIds(new Set<Id>{con.Id});
        conSel.getContactsByAccountId(acc.Id);
        
        // 4. IntegrationSettingSelector
        GEN_IntegrationSettingSelector setSel = new GEN_IntegrationSettingSelector();
        setSel.getSObjectType();
        setSel.getSObjectFieldList();
        // Uses a fake ID just to run the query lines
        setSel.getSettingByUniqueIdentifiers(new List<String>{'DocGen_OAuth_Dev'});

        Test.stopTest();
    }
}


@isTest
public class GENAccountDocumentServiceMock implements HttpCalloutMock {
    // This flag allows the test to force a 502 error
    public Boolean simulateBadGateway = false;

    public HTTPResponse respond(HTTPRequest req) {
        HttpResponse res = new HttpResponse();
        res.setStatusCode(200);
        res.setHeader('Content-Type', 'application/json');
        
        String endpoint = req.getEndpoint();

        // 1. Simulate 502 Bad Gateway (HTML Response)
        if (simulateBadGateway) {
            res.setStatusCode(502);
            res.setBody('<html><body>502 Bad Gateway</body></html>');
            return res;
        }

        // 2. Normal Responses
        if (endpoint.contains('oauth') || endpoint.contains('token')) {
            res.setBody('{"access_token": "mock_token_123", "token_type": "Bearer"}');
        } 
        else if (endpoint.contains('generate')) {
            res.setBody('{"success": true, "data": {"pdf_base64": "JVBERi0xLg=="}}'); 
        } 
        else if (endpoint.contains('send')) {
            res.setBody('{"success": true, "message": "Document sent for signature"}');
        }
        else {
            res.setStatusCode(404);
        }
        return res;
    }
}



@isTest
public class GEN_AccountDocumentControllerMock implements HttpCalloutMock {
    
    public HTTPResponse respond(HTTPRequest req) {
        HttpResponse res = new HttpResponse();
        res.setStatusCode(200);
        res.setHeader('Content-Type', 'application/json');
        
        String endpoint = req.getEndpoint();
        
        // 1. OAUTH (Used by both Generate and Send)
        if (endpoint.contains('oauth') || endpoint.contains('token')) {
            res.setBody('{"access_token": "mock_test_token_123", "token_type": "Bearer"}');
        } 
        // 2. GENERATE (Covers NDA and RPA)
        else if (endpoint.contains('generate')) {
            // Returns a dummy PDF string
            res.setBody('{"success": true, "data": {"pdf_base64": "JVBERi0xLg=="}}'); 
        } 
        // 3. SEND SIGNATURE
        else if (endpoint.contains('send')) {
            res.setBody('{"success": true, "message": "Document sent for signature"}');
        }
        else {
            res.setStatusCode(404);
        }
        
        return res;
    }
}





// 1. FETCH TEST DATA
// We need a Contact with an email address.
List<Contact> contacts = [SELECT Id, Name, Email FROM Contact WHERE Email != null LIMIT 1];
if (contacts.isEmpty()) {
    System.debug('❌ ERROR: No Contacts found with an email address. Please create one first.');
    return;
}
Contact testContact = contacts[0];

// We need a valid File (ContentDocument) to send.
List<ContentVersion> files = [SELECT ContentDocumentId, Title FROM ContentVersion WHERE IsLatest = true LIMIT 1];
if (files.isEmpty()) {
    System.debug('❌ ERROR: No Files found in the Org. Please upload a file to an Account first.');
    return;
}
Id testDocumentId = files[0].ContentDocumentId;

System.debug('--- TEST DATA ---');
System.debug('Contact: ' + testContact.Name + ' (' + testContact.Email + ')');
System.debug('Document: ' + files[0].Title + ' (ID: ' + testDocumentId + ')');
System.debug('-----------------');

// 2. CALL THE SERVICE
// The method requires (ContactID, ContentDocumentID)
System.debug('>>> Calling sendDocumentForSignature...');
Map<String, Object> result = GEN_AccountDocumentService.getInstance().sendDocumentForSignature(testContact.Id, testDocumentId);

// 3. ANALYZE RESULT
String status = (String) result.get('message');
Object response = result.get('response');

if (status == 'success') {
    System.debug('✅ SUCCESS: Signature Request Sent!');
    System.debug('Details: ' + response);
} else {
    System.debug('❌ FAILURE: Could not send signature request.');
    System.debug('Error Message: ' + response);
}










// REPLACE THIS ID WITH YOUR ACTUAL ACCOUNT ID
Id accId = '001QJ00000ny0c2YAA'; 

System.debug('--- STARTING DEBUG ---');

// 1. Test the Service Method directly
Map<String, Object> result = GEN_AccountDocumentService.getInstance().getSendOptions(accId);

System.debug('Result Message: ' + result.get('message'));

if (result.get('message') == 'success') {
    Map<String, Object> data = (Map<String, Object>) result.get('response');
    
    // Check Contacts
    List<Contact> conList = (List<Contact>) data.get('contacts');
    System.debug('✅ Contacts Found: ' + conList.size());
    for(Contact c : conList) {
        System.debug('   - ' + c.FirstName + ' ' + c.LastName + ' (' + c.Email + ')');
    }
    
    // Check Documents
    List<ContentDocument> docList = (List<ContentDocument>) data.get('documents');
    System.debug('✅ Documents Found: ' + docList.size());
    for(ContentDocument d : docList) {
        System.debug('   - ' + d.Title + ' (ID: ' + d.Id + ')');
    }
} else {
    System.debug('❌ Service Failed: ' + result);
}

System.debug('--- END DEBUG ---');


public with sharing class GEN_AccountDocumentController {

    @AuraEnabled(cacheable=true)
    public static Map<String, Object> getSendOptions(Id accountId) {
        try {
            return GEN_AccountDocumentService.getInstance().getSendOptions(accountId);
        } catch (Exception e) {
            return new Map<String, Object>{
                'message' => 'error',
                'response' => 'System Error: ' + e.getMessage()
            };
        }
    }

    @AuraEnabled
    public static Map<String, Object> generateDocument(String documentType, Id accountId) {
        try {
            return GEN_AccountDocumentService.getInstance().generateAndSavePdf(documentType, accountId);
        } catch (Exception e) {
            return new Map<String, Object>{
                'message' => 'error',
                'response' => 'System Error: ' + e.getMessage()
            };
        }
    }

    @AuraEnabled
    public static Map<String, Object> sendDocumentForSignature(Id contactId, Id documentId) {
        try {
            return GEN_AccountDocumentService.getInstance().sendDocumentForSignature(contactId, documentId);
        } catch (Exception e) {
            return new Map<String, Object>{
                'message' => 'error',
                'response' => 'System Error: ' + e.getMessage()
            };
        }
    }
}


@isTest
private class GEN_AccountDocumentServiceTest {

    @testSetup
    static void setupData() {
        // Create a test Account required for Document Generation
        Account acc = new Account(
            Name = 'Test Account',
            Company_Registration_Number__c = '123456', 
            Company_Registration_Location__c = 'London'
        );
        insert acc;

        // Create a test Contact required for Signature Sending
        Contact con = new Contact(
            FirstName = 'Test',
            LastName = 'User',
            Email = 'test@example.com',
            AccountId = acc.Id
        );
        insert con;
    }

    @isTest
    static void testGenerateAndSavePdf_Success() {
        // 1. Get Test Data
        Account acc = [SELECT Id FROM Account LIMIT 1];

        // 2. Set the Mock
        Test.setMock(HttpCalloutMock.class, new GEN_AccountDocumentServiceMock());

        // 3. Run the Test
        Test.startTest();
        // We use 'nda' (lowercase) as we identified this is required by the API
        Map<String, Object> result = GEN_AccountDocumentService.getInstance().generateAndSavePdf('nda', acc.Id);
        Test.stopTest();

        // 4. Minimal Assertions
        System.assertEquals('success', result.get('message'), 'PDF Generation should return success message');
        
        // Verify a ContentVersion (File) was actually created
        List<ContentVersion> files = [SELECT Id, Title FROM ContentVersion WHERE FirstPublishLocationId = :acc.Id];
        System.assertEquals(1, files.size(), 'A file should be attached to the Account');
    }

    @isTest
    static void testSendDocumentForSignature_Success() {
        // 1. Get Test Data
        Account acc = [SELECT Id FROM Account LIMIT 1];
        Contact con = [SELECT Id FROM Contact LIMIT 1];

        // 2. Create a Dummy File (ContentVersion) to send
        // This is needed because the service queries for the "latest published version"
        ContentVersion cv = new ContentVersion(
            Title = 'NDA.pdf',
            PathOnClient = 'NDA.pdf',
            VersionData = Blob.valueOf('Fake PDF Content'),
            FirstPublishLocationId = acc.Id
        );
        insert cv;
        
        // Fetch the Document ID (ContentDocumentId) wrapper
        Id docId = [SELECT ContentDocumentId FROM ContentVersion WHERE Id = :cv.Id].ContentDocumentId;

        // 3. Set the Mock
        Test.setMock(HttpCalloutMock.class, new GEN_AccountDocumentServiceMock());

        // 4. Run the Test
        Test.startTest();
        Map<String, Object> result = GEN_AccountDocumentService.getInstance().sendDocumentForSignature(con.Id, docId);
        Test.stopTest();

        // 5. Minimal Assertion
        System.assertEquals('success', result.get('message'), 'Sending for signature should return success message');
        
        // Verify a Task was created (as per your service logic)
        List<Task> tasks = [SELECT Id FROM Task WHERE WhoId = :con.Id];
        System.assertEquals(1, tasks.size(), 'A task should be created after sending signature request');
    }
}


@isTest
public class GEN_AccountDocumentServiceMock implements HttpCalloutMock {
    
    public HTTPResponse respond(HTTPRequest req) {
        HttpResponse res = new HttpResponse();
        res.setStatusCode(200);
        res.setHeader('Content-Type', 'application/json');
        
        String endpoint = req.getEndpoint();
        
        // 1. Handle Authentication Callout
        if (endpoint.contains('oauth') || endpoint.contains('token')) {
            // Returns the token structure your service expects
            res.setBody('{"access_token": "mock_test_token_123", "token_type": "Bearer"}');
        } 
        // 2. Handle Document Generation Callout
        else if (endpoint.contains('generate')) {
            // Returns the nested JSON structure: { data: { pdf_base64: "..." } }
            // This matches the parsing logic in your Service class
            res.setBody('{"success": true, "data": {"pdf_base64": "JVBERi0xLg=="}}'); 
        } 
        // 3. Handle Signature Sending Callout
        else if (endpoint.contains('send')) {
            // Returns a generic success message
            res.setBody('{"success": true, "message": "Document sent for signature"}');
        }
        else {
            // Fallback for unknown endpoints
            res.setStatusCode(404);
            res.setBody('{"message": "Endpoint not found in mock"}');
        }
        
        return res;
    }
}






